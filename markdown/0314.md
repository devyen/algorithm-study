## 1992 쿼드트리

- idea: 재귀를 이용해 더 작은 문제로 쪼갠다.

- 아무리봐도 맞는 것 같은데 6번을 틀렸다. 질문 게시판에서 여러 반례를 찾아 넣어봐도 맞게 나와서 뭐가 문제인지 모르겠어서 한참 헤멨다.

- 문제는 이거였다!

  **코드**

  ```python
  if a == b == c == d:
      if a == '1':
          return '1'
      else:
          return '0'
  ```

  **반례**

  ```
  4
  1010
  0000
  1010
  0000
  ```

   `else:` 가 문제였다. 

  반례의 경우 a, b, c, d가 `(1000)`으로 같기 때문에 `a == b == c == d`을 만족시키는데, `'1'` 이나 `'0'`이 아니므로 걸러내야한다. 하지만 위의 코드에선 `a == '1'`이 아닌 건 `else`로 모두 처리해버리기 때문에 문제이다. 

  `else`가 아니라 `elif a == '0'`으로 바꿔야한다!

  **수정**

  ```python
  if a == b == c == d:
      if a == '1':
          return '1'
      elif a == '0':
          return '0'
  ```

  

## 11729 하노이 탑 이동 순서

- 하노이탑 알고리즘을 찾아봤다.

  참고: https://brunch.co.kr/@younggiseo/139

- idea: 재귀로 더 n-1개를 옮기는 함수를 호출한다.

- 알고리즘

  1. 판이 1개면 그냥 옮기면 된다. (base case)

  2. 판이 n개이면

     ```python
     1. 장대1에 있는 n-1개의 판을 장대2로 옮긴다. (보조: 장대3)
     2. 장대1에 남아있는 마지막 판(가장 큰 판)을 장대3으로 옮긴다.
     3. 장대2의 n-1개의 판을 장대3으로 옮긴다. (보조: 장대1)
     ```



## 10827 a^b

- 분할정복..?
  - divide & conquer

- 어떻게 쪼갤 수 있을까?

  1. 정수부 + 소수부로 쪼개기

     (a+b)^3 = (a+b)(a+b)(a+b) = a^3 + b^3 + 3ab(a+b)

     몇제곱이냐에 따라 공식이 달라지므로 안될 것 같음..

  2. 소수점을 정수로 올려버리기

     최대 소수점이 9자리이므로 1000000000 를 곱한다.

     => 예제 1, 3은 되는데 예제2같은 경우는 안된다