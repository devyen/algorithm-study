## Level1. 크레인 인형뽑기 게임

- 같은 인형이 연속해서 들어오면 이전에 들어온 인형을 pop하기 위해 `deque` 을 썼다.

- 근데 `deque`을 안 써도 통과된다!

- 풀이: basket의 마지막 인형인 last와 현재 뽑은 인형인 pick을 비교해서, 둘이 같은 경우엔 basket에서 하나를 pop 하고 answer에 2를 더해주고, 다른 경우엔 pick을 append 한다.

- Point

  - ```
    move -= 1
    ```

    moves의 원소가 1열부터 시작하기 때문에 index 에러가 났다. 그래서 처음에 1씩 뺐다.

  - 방문표시를 -1로 하여 조건문을 `if pick > 0` 으로 처리했다.





## Level1. 실패율

- 런타임에러..?
  - 정렬 시간 문제인가 해서 `heapq`를 써봤는데 적용하고보니`heapq` 는 최소값만 보장하고 전체 정렬을 보장하지 않는다. `heapq`는 아님
  - sort를 두 번 한게 문제인가 해서 lambda로 통합했는데 여전히 런타임 에러 발생.





## Level2. 거리두기 확인하기

- visited 체크를 하며 맨하탄 거리 2까지 **dfs 탐색**
- flag를 통해 하나라도 거리두기가 지켜지지 않은 곳을 찾으면 모든 함수들이 종료되도록 했다.
- 새로 배운 것:`nonlocal`
  - `global` 선언처럼, `nonlocal` 선언을 하면 local 외부의 nonlocal 범위에 접근할 수 있다.





## Level2. 튜플

- idea
  - 튜플의 부분집합들이므로 먼저 길이로 정렬한다.
  - 원소를 순서대로 구하기 위해선 이전 부분집합에 포함되지 않은 원소 하나를 찾으면 된다 -> `set`의 차집합 활용
- 차집합 구하는 법 2가지
  1. `set1 - set2`
  2. `set1.differnece(set2)`

- s 처리
  - string으로 주어진 s를 set으로 만드는 것이 조금 까다로웠다.
  - 먼저 '}' 기준으로 split 했다.
  - `subsets` 라는 리스트를 만들고 그 안에 집합들을 넣었다.



