# 05.02

## :world_map: Level1. 비밀지도

- 10진수 -> 2진수 변환을 나눗셈으로 구현했다.
- 그치만 python 내장함수를 이용할 수도 있다!

- 문자열로 출력하는건 `join`을 썼다!



- #### 10진수에서 2진수, 8진수, 16진수 변환

  - bin(), oct(), hex()

  ```python
  >>> bin(42)
  '0b101010'
  >>> oct(42)
  '0o52'
  >>> hex(42)
  '0x2a'
  ```

  - format()

  ```python
  # 접두어 포함된 결과 반환
  >>> format(42, '#b')
  '0b101010'
  >>> format(42, '#o')
  '0o52'
  >>> format(42, '#x')
  '0x2a'
  >>> format(42, '#X')
  '0X2A'
  
  # 접두어 없이 반환
  >>> format(42, 'b')
  '101010'
  >>> format(42, 'o')
  '52'
  >>> format(42, 'x')
  '2a'
  >>> format(42, 'X')
  '2A'
  >>> format(42, 'd')
  '42'
  ```

- #### 다른 진수 형태에서 10진수로 변환

```python
>>> int('0b101010', 2)
42
>>> int('0o52', 8)
42
>>> int('0x2a', 16)
```



## :dart: Level1. 다트게임

- 문자열의 원소를 하나씩 순회하면서 'S', 'D', 'T'를 기준으로 scores에 append하고 score를 초기화 했다.
- 원래는 숫자가 나올 때 append했는데, 십의 자리 이상의 숫자를 쪼개버리는 문제 발생 -> 숫자가 나올 땐 문자열로 더하고, 'S', 'D', 'T' 가 나왔을 때 숫자로 변환하고 append하는 방식으로 바꿈
- '*', '#' 이 나올 땐 scores[-1], scores[-2]를 뽑아서 처리했다.



## :newspaper: Level2. 뉴스 클러스터링

- 다중집합을 허용하기 때문에 set은 못 쓸 것 같다.
- 그럼 교집합을 어떻게 구할까?
  - 집합A를 돌면서 딕셔너리로 카운트하고, 그다음 집합B를 돌면서 겹치는걸 카운트 하는 방식

-  합집합은
  - 카운트한 딕셔너리에 해당 원소가 없으면 합집합에 새로운 원소를 추가하는 방식

- #### 풀이 순서

1. 먼저 set1을 돌면서 `el_count` 딕셔너리에 카운트한다.
2. set2를 돌면서 해당 원소가 `el_count` 에 있으면 교집합 개수인 `inter`를 +1하고, `el_count[el]`에서는 1을 빼준다. (이유: 그래야 양쪽의 다중 중복을 제대로 체크할 수 있다.)
3. 해당 원소가 `el_count`에 없으면 합집합에 새로운 원소를 추가해야하므로 합집합 개수 `union`을  +1 한다.



- 집합 A, B 모두 공집합일 경우를 따로 처리해줘야함





## :shallow_pan_of_food: Level2. 메뉴 리뉴얼

- 부분집합 어케 만들지.. -> 2**n 이진수로 비트 활용
- subsets 딕셔너리로 부분집합 카운트
- 각 길이별로 가장 많이 주문된 조합을 구하기 위해 tmp에서 갱신

