# 06.13

## :heavy_plus_sign: Level2. 수식 최대화

- 주어진 수식에 들어있는 연산자의 우선순의를 정해 가장 큰 숫자를 만들어내는 문제
- 우선순위 순열을 만들고, 완전탐색을 해서 최대값을 찾아냈다.
- `splited` 에서 계산한 결과를 계산 전 숫자들과 어떻게 치환할지 생각하는 것이 조금 어려웠다.



## :apple: Level2. 괄호 변환

- 함수 3개를 만들었다.
  1. `is_wright` : 올바른 괄호 문자열인지 검사하는 함수
     - 싸피 수업 때 했던 괄호 처리를 떠올리며 stack을 썼다.
     - 근데 그냥 cnt로 숫자만 세도 될 것 같다.
  2. `get_reverse` : `(` 와 `)` 방향을 바꾼 결과를 반환하는 함수
  3. `bracket` : 재귀함수
     - 문제에서 알려준 논리대로 구현했다.



## :key: Level2. 후보키

#### idea

- 최소성
  - 최소성을 지키려면 이미 후보키인 속성이 겹치지 않으면 됨
  - 방법
    1) 속성 1개짜리부터 순차적으로 체크
    2) 후보키와 속성이 겹치는 조합은 패스하기
- 유일성
  - set으로 중복 요소가 있는지 검사

#### 틀린 이유

![image-20220613100450143](0613.assets/image-20220613100450143.png)

```python
for key in candidate_keys:
    a = set(key)
    b = set(comb)
    if len(a & b) > 0:
        flag = 1
        break
```

- 문제: 최소성을 체크하는 부분에서 `if len(a & b) > 0:` 가 문제였다.

- 이유: 교집합이 있기만 하면 걸러냈기 때문. 
  하지만 교집합이 있는지가 아니라 집합 a가 b에 포함되어있는지를 확인해야하기 때문에 교집합의 길이가 a의 길이와 같은지를 확인했다.

- 수정

  ```python
  if len(a & b) == len(a):
  ```

  

## :cherry_blossom: Level2. 프렌즈4블록

- 규칙

  - 2*2 형태로 같은 블록이 붙어있으면 터트린다.

  - 터지는 블록이 몇 개인지 구하는 문제

- 풀이 포인트

  - 같은 블록이 여러 2*2에 포함될 수 있으므로 탐색 먼저 한다.

  - 중복되는 블록은 set으로 제거
    - pang_blocks를 sort해 윗행부터 순서대로 터트린다. 그래야 블록들을 올바르게 터트릴 수 있다.
      - 만약 아래 행을 먼저 터트리면, 터트린 자리에 블록들이 아래로 내려오면서 좌표가 변하게 된다. 그럼 아직 남아있는 터트려야할 블록들의 좌표도 변하게 된다.

  - 더 이상 터트릴 게 없을 때까지 반복